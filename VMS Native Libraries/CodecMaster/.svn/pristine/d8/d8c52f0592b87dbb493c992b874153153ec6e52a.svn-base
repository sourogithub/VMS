/*
 * StreamMaster.cpp
 *
 *  Created on: 06-Oct-2018
 *      Author: dss-06
 */

#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <sys/time.h>
using namespace std;

#include "CodecMaster.h"
#include "DataTypes.h"
#include "ErrorTypes.h"
#include "config_SM.h"
//#include <saveframes.h.bak>
//#include "MediaTypes.h"
//#include "ColorSpace.h"

#define INBUF_SIZE 4096
#define AUDIO_INBUF_SIZE 20480
#define AUDIO_REFILL_THRESH 4096

#define VIDEO_TMP_FILE "tmp.h264"
//#define FINAL_FILE_NAME "record.mp4"

/*
 * Global dataspace for the module
 */
UINT8 *globalDataSpace_d = NULL;
pthread_mutex_t ml;

typedef struct _DecodeDataSpace
{
	AVCodec *pCodec;
	AVCodecContext *pCodecCtx;
	SwsContext *img_convert_ctx;
	int size,size2;
	uint8_t* picture_buf;
	AVFrame* pic,* picrgb;
	uint8_t* picture_buf2;
	AVPacket packet;
	int decodesize;
	char fname[100];
	int frameFinished;

	_DecodeDataSpace()
	{
		//		pFormatCtx = NULL;
		//		count = 1;
		//		difference = 0;
	}

	~_DecodeDataSpace()
	{

	}
}DecodeDataSpace;


typedef enum _MediaTypes_
{
	H264 						= 0,
	H265						= 1,
	MJPEG						= 2,
	MPEG4 						= 3,
	MP4 						= 4,
	MOV 						= 5,
	AVI							= 6,
	MKV							= 7,
	FLV							= 8,
	JPEG						= 9,
	JPG							= 10
}MediaTypes;

typedef enum _ColorSpace_
{
	RGB 						= 0,
	CMYK						= 1,
	CIE							= 2,
	YUV 						= 3,
	HSV 						= 4,
	HSL 						= 5
}ColorSpace;

ErrorTypes Initialize()
{
	//TO DO: Call RTSP initializer here

	globalDataSpace_d = (UINT8 *)(new DecodeDataSpace);

	if ( NULL == globalDataSpace_d )
	{
		return DSS_ERROR;
	}

	avcodec_register_all();
	av_register_all();

	if (pthread_mutex_init(&ml, NULL) != 0){
		printf("\n mutex init has failed\n");
		return DSS_ERROR;
	}

	printf("I am Initialized in decoding\n");
	return DSS_SUCCESS;
}

ErrorTypes AddDecoder(UINT8 *dataSpace, const CHAR8 mediaType,
		const CHAR8 colorSpace)
{
	if (*((INT32 *)dataSpace) < (INT32)sizeof(DecodeDataSpace *)){
		*((INT32 *)dataSpace) = sizeof(DecodeDataSpace *);
		return DSS_INSUFICIENT_MEMORY;
	}
	printf("I am in add decode\n");
	pthread_mutex_lock(&ml);
	DecodeDataSpace *sDataSpace = new DecodeDataSpace();
	pthread_mutex_unlock(&ml);

	//printf("I am in add decode\n");

	sDataSpace->pCodec = avcodec_find_decoder((AVCodecID)28);

	sDataSpace->pCodecCtx = avcodec_alloc_context3(sDataSpace->pCodec);
	sDataSpace->pCodecCtx->width = 1280;
	sDataSpace->pCodecCtx->height = 720;
	//	pCodecCtx->width = 640;
	//	pCodecCtx->height = 480;
	sDataSpace->pCodecCtx->pix_fmt = AV_PIX_FMT_YUV420P;
	SwsContext *img_convert_ctx;

	avcodec_open2(sDataSpace->pCodecCtx, sDataSpace->pCodec, NULL);

	sDataSpace->img_convert_ctx = sws_getContext(sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height, sDataSpace->pCodecCtx->pix_fmt, sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height,
			AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);

	sDataSpace->size = avpicture_get_size(AV_PIX_FMT_YUV420P, sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height);
	sDataSpace->picture_buf = (uint8_t*)(av_malloc(sDataSpace->size));
	sDataSpace->pic = av_frame_alloc();
	sDataSpace->picrgb = av_frame_alloc();
	sDataSpace->size2 = avpicture_get_size(AV_PIX_FMT_RGB24, sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height);
	sDataSpace->picture_buf2 = (uint8_t*)(av_malloc(sDataSpace->size2));
	avpicture_fill((AVPicture *) sDataSpace->pic, sDataSpace->picture_buf, AV_PIX_FMT_YUV420P, sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height);
	avpicture_fill((AVPicture *) sDataSpace->picrgb, sDataSpace->picture_buf2, AV_PIX_FMT_RGB24, sDataSpace->pCodecCtx->width, sDataSpace->pCodecCtx->height);

	av_init_packet(&sDataSpace->packet);

	//*((UINT64 *)dataSpace + sizeof(int)) = (UINT64)sDataSpace;
	*((UINT64 *)dataSpace + sizeof(char)) = (UINT64)sDataSpace;

	return DSS_SUCCESS;
}

ErrorTypes RemoveDecoder(UINT8 *dataSpace)
{
	return DSS_SUCCESS;
}

ErrorTypes Decode(UINT8 *dataSpace, UINT8 *encodedBuffer, UINT32 *decodedBuffer)
{
	pthread_mutex_lock(&ml);
	DecodeDataSpace *sDataSpace = (DecodeDataSpace *)(*((UINT64 *)dataSpace + sizeof(char)));
	pthread_mutex_unlock(&ml);

	int bufferSize = *(int *)encodedBuffer;
	printf("Size of encoded buffer = %d\n",bufferSize);
	int extra = sizeof(int) + sizeof(int64_t) + sizeof(int64_t);

	sDataSpace->packet.flags = *((int *)(encodedBuffer + sizeof(int)));
	sDataSpace->packet.pts = *((int64_t *)(encodedBuffer + sizeof(int) + sizeof(int)));
	sDataSpace->packet.dts = *((int64_t *)(encodedBuffer + sizeof(int) + sizeof(int) + sizeof(int64_t)));
	sDataSpace->packet.data = encodedBuffer + sizeof(int) + sizeof(int) + sizeof(int64_t) + sizeof(int64_t);
	sDataSpace->packet.size = bufferSize - extra;

	int len = avcodec_decode_video2(sDataSpace->pCodecCtx, sDataSpace->pic, &sDataSpace->frameFinished, &sDataSpace->packet);
	printf("Status of avcodec = %d\n",len);
	//printf("Format = %d\n",sDataSpace->pCodecCtx->pix_fmt);
	if(len < 0)
	{
		return DSS_ERROR;
	}
	//exit(1);
#if 1
	//Testing
	int fileLen = sDataSpace->pCodecCtx->width * sDataSpace->pCodecCtx->height * sizeof(int);	// Multiply by 4 because of int type convertion  from char
	printf("File length = %d\n",fileLen);

	if (*((INT32 *)decodedBuffer) < fileLen + sizeof(int) + sizeof(int)){
		*((INT32 *)decodedBuffer) = sDataSpace->pCodecCtx->width * sDataSpace->pCodecCtx->height;
		printf("Returning INSUFFICIENT MEMORY: SIZE REQUIRED - %d \n", sDataSpace->pCodecCtx->width * sDataSpace->pCodecCtx->height);
		return DSS_INSUFICIENT_MEMORY;
	}
	//Allocate
	//	unsigned int *decodedCopy = (unsigned int *)calloc(sizeof(int), sDataSpace->pCodecCtx->width * sDataSpace->pCodecCtx->height);
	//	*decodedBuffer = fileLen + sizeof(int) + sizeof(int);

	*(decodedBuffer + sizeof(char)) = sDataSpace->pCodecCtx->width;
	printf("Width in c = %d\n", *(decodedBuffer + sizeof(char)));

	*(decodedBuffer + sizeof(char) + sizeof(char)) = sDataSpace->pCodecCtx->height;
	printf("Height in c = %d\n", *(decodedBuffer + sizeof(char) + sizeof(char)));

	sws_scale(sDataSpace->img_convert_ctx, sDataSpace->pic->data, sDataSpace->pic->linesize, 0, sDataSpace->pCodecCtx->height, sDataSpace->picrgb->data, sDataSpace->picrgb->linesize);

	int count = 3;//sizeof(char) + sizeof(char) + sizeof(char);
	//writing data

	FILE *fp;
	static int counter = 0;
	char name[30];
	sprintf(name, "dumpCheck_%d.ppm", counter++);
	fp = fopen(name, "wb");

	if(fp){
		fprintf(fp,"P6\n%d %d\n%d\n",sDataSpace->pCodecCtx->width,sDataSpace->pCodecCtx->height,255);

		for(int h_index = 0; h_index < sDataSpace->pCodecCtx->height; h_index++)
		{
			unsigned char RGB[3];
			for(int w_index = 1; w_index <= sDataSpace->pCodecCtx->width * 3; w_index++)
			{
				char data = (sDataSpace->picrgb->data[0] + h_index * sDataSpace->picrgb->linesize[0])[w_index - 1];
				RGB[(w_index - 1) % 3] = data;

				if(w_index % 3 == 0) {
					// i have got RGB values
					//now all we need to do is put into the buffer in correct format
					int rgbData = 0;
					char alpha = 255;
					//RGB -> 0:red  1:green  2:blue
					rgbData = (alpha << 24) | (RGB[0] << 16) | (RGB[1] << 8) | (RGB[2] << 0);

//					fprintf(fp, "%c",(RGB[0] << 16));
//					fprintf(fp, "%c",(RGB[1] << 8));
//					fprintf(fp, "%c",(RGB[2] << 0));

					decodedBuffer[count++] = rgbData;
				}
			}
		}

		fclose(fp);
	}

#endif

#if 0
	FILE *fp;
	static int c = 0;
	sprintf(sDataSpace->fname, "result_from_c_%d.ppm", c++);
	fp = fopen(sDataSpace->fname, "wb");
	if(fp)
	{
		sws_scale(sDataSpace->img_convert_ctx, sDataSpace->pic->data, sDataSpace->pic->linesize, 0, sDataSpace->pCodecCtx->height, sDataSpace->picrgb->data, sDataSpace->picrgb->linesize);
		fprintf(fp,"P6\n%d %d\n%d\n",sDataSpace->pCodecCtx->width,sDataSpace->pCodecCtx->height,255);

		for(int i=0;i<sDataSpace->pCodecCtx->height;i++) {
			fwrite(sDataSpace->picrgb->data[0] + i * sDataSpace->picrgb->linesize[0], 1, sDataSpace->pCodecCtx->width * 3, fp);
		}


		fclose(fp);
	}
	else
	{
		printf("Error opening file\n");
		exit(1);
	}
#endif
	//count++;
	//av_free_packet(&sDataSpace->packet);
	//av_init_packet(&sDataSpace->packet);


	return DSS_SUCCESS;

	//	av_free(pic);
	//	av_free(picrgb);
	//	av_free(picture_buf);
	//	av_free(picture_buf2);

}


//void *Test(void *arg)
//{
//	if (pthread_mutex_init(&ml, NULL) != 0){
//		printf("\n mutex init has failed\n");
//		return NULL;
//	}
//
//	//StreamDataSpace *sDataSpace;
//	Data *d = (Data *)arg;
//
//	d->count = 1;
//	while(true)
//	{
//		if(d->count == 1)
//		{
//			AddStream(d->buffer, d->model, d->url, d->user, d->pass, d->camId);
//			d->count++;
//		}
//
//		int x = GetContent(d->buffer, d->dataBuffer);
//		printf("\nReturn Status = %d\n",x);
//	}
//	pthread_mutex_destroy(&ml);
//	return NULL;
//}


ErrorTypes Decode(const CHAR8 mediaType, const CHAR8 colorSpace,
		UINT8 *encodedBuffer, UINT32 *decodedBuffer)
{
	return DSS_SUCCESS;
}

ErrorTypes addEncoder(UINT8 *dataSpace, const CHAR8 codec, const CHAR8 colorSpace,
		const UINT32 width, const UINT32 height, const UINT32 bitRate)
{
	return DSS_SUCCESS;
}

ErrorTypes removeEncoder(UINT8 *dataSpace)
{
	return DSS_SUCCESS;
}

ErrorTypes enocode(UINT8 *dataSpace, UINT8 *encodedBuffer, UINT32 *decodedBuffer)
{
	return DSS_SUCCESS;
}

ErrorTypes TearDown()
{
	//TO DO: close RTSP stream here
	//	av_free(pic);
	//	av_free(picrgb);
	//	av_free(picture_buf);
	//	av_free(picture_buf2);


	//	delete (SMDataSpace *)globalDataSpace;
	//
	//		if ( NULL != globalDataSpace )
	//		{
	//			return DSS_ERROR;
	//		}

	return DSS_SUCCESS;
}
